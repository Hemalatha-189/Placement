1) The program must accept two integers X and Y as the input. The program must print an integer C whose binary representation 
indicates the same bits at the odd positions from LSB (Least Significant Bit) of the integers X and Y. 
If there are no bits same at odd positions, then the program must print -1 as the output.
Input:109 107
Output:5
109 -> 1101101
107 -> 1101011
x, y = map(int, input().split())
bx = bin(x)[2:]
by = bin(y)[2:]

# Pad both binary strings to the same length
maxlen = max(len(bx), len(by))
bx = bx.zfill(maxlen) (zfill means used to compensate the 0s in the binary value)
by = by.zfill(maxlen)

res = []
# Traverse from LSB to MSB (rightmost to leftmost)
for i in range(maxlen-1, -1, -1):
    pos = maxlen - i  # Position from LSB (1-based)
    if pos % 2 == 1:  # Odd positions only
        if bx[i] == by[i]:
            res.append(bx[i])

if not res:
    print(-1)
else:
    # Since we traverse from LSB to MSB, reverse and join to form the correct binary number
    print(int(''.join(res[::-1]), 2))  # reverse to go from MSB to LSB

2) Given three sorted arrays A, B, and C, merge them into one sorted array. For each number in the merged result,
print the original array and its index (as a0, b1, c2, etc.).

Sample Input

5
10 20 50 90 100
4
15 25 35 40
6
5 30 39 45 60 98
Sample Output
c0 a0 b0 a1 b1 c1 b2 c2 b3 c3 a2 c4 a3 c5 a4

n1 = int(input())
arr1 = list(map(int, input().split()))
n2 = int(input())
arr2 = list(map(int, input().split()))
n3 = int(input())
arr3 = list(map(int, input().split()))

combined = []
for i, val in enumerate(arr1):
    combined.append((val, f"a{i}"))
for i, val in enumerate(arr2):
    combined.append((val, f"b{i}"))
for i, val in enumerate(arr3):
    combined.append((val, f"c{i}"))

combined.sort()  
res = [idx for val, idx in combined]
print(' '.join(res))

